rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =============================================================================
    // HELPER FUNCTIONS - Reusable logic to minimize rule duplication
    // =============================================================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isGroupMember(groupId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/groups/$(groupId)).data.members[request.auth.uid] != null;
    }
    
    function isGroupAdmin(groupId) {
      return isAuthenticated() && 
             (get(/databases/$(database)/documents/groups/$(groupId)).data.admin == request.auth.uid ||
              get(/databases/$(database)/documents/groups/$(groupId)).data.members[request.auth.uid].role == 'admin');
    }
    
    function isCreator(groupId) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/groups/$(groupId)).data.createdBy == request.auth.uid;
    }
    
    // Check if query is searching by invite code (for group joining)
    function isInviteCodeQuery() {
      return request.query.where.size() == 1 && 
             request.query.where[0].field == "inviteCode";
    }
    
    // Check if the update is only adding the current user as a member
    function isJoiningGroup() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['members', 'memberCount', 'updatedAt', 'lastActivity']) &&
             request.resource.data.members.keys().hasOnly([request.auth.uid]) &&
             request.resource.data.members[request.auth.uid] != null;
    }
    
    // Flexible field validation - allows core fields plus custom ones
    function isValidGroupUpdate() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      let allowedFields = ['name', 'description', 'category', 'updatedAt', 'lastActivity', 
                          'avatar', 'settings', 'status', 'location'];
      return affectedKeys.hasAny(allowedFields);
    }
    
    // Development mode toggle (optional - remove in production)
    function isDevMode() {
      return exists(/databases/$(database)/documents/config/settings) && 
             get(/databases/$(database)/documents/config/settings).data.devMode == true;
    }
    
    // =============================================================================
    // MAIN COLLECTION RULES
    // =============================================================================
    
    // Users collection - users control their own data
    match /users/{userId} {
      allow read, write: if isOwner(userId);
      
      // Allow limited read access for friend searches and group member info
      allow read: if isAuthenticated() && 
                     (request.query.where.size() > 0 || // Search queries
                      exists(/databases/$(database)/documents/groups) // Group context
                     );
    }
    
    // Groups collection - flexible group access
    match /groups/{groupId} {
      // Read: Members can read, or invite code queries
      allow read: if isAuthenticated() && 
                     (isGroupMember(groupId) || isInviteCodeQuery());
      
      // Create: Any authenticated user can create groups
      allow create: if isAuthenticated();
      
      // Update: Admins can update structure, anyone can join via invite
      allow update: if isAuthenticated() && 
                       (isGroupAdmin(groupId) || isJoiningGroup());
      
      // Delete: Only creators can delete
      allow delete: if isCreator(groupId);
      
      // =============================================================================
      // SUBCOLLECTIONS - Generic rules that work for current and future collections
      // =============================================================================
      
      // Universal subcollection access pattern
      match /{subcollection}/{docId} {
        // Default: members can read, admins can write
        allow read: if isGroupMember(groupId);
        allow write: if isGroupAdmin(groupId);
        
        // Specific overrides for known subcollections
        
        // Messages: members can create their own
        match /messages/{messageId} {
          allow create: if isGroupMember(groupId) && 
                           request.resource.data.userId == request.auth.uid;
          allow update: if false; // No message editing
        }
        
        // Locations: members can manage their own
        match /locations/{locationId} {
          allow write: if isGroupMember(groupId) && 
                          (locationId == request.auth.uid || isGroupAdmin(groupId));
        }
        
        // Votes: users can only vote for themselves
        match /votes/{voteId} {
          allow write: if isGroupMember(groupId) && voteId == request.auth.uid;
        }
        
        // Events: members can create, admins can manage all
        match /events/{eventId} {
          allow create: if isGroupMember(groupId);
          allow update, delete: if isGroupAdmin(groupId) || 
                                   resource.data.createdBy == request.auth.uid;
        }
        
        // Any future subcollections automatically inherit the default rules above
      }
    }
    
    // Friend requests collection - handles friend system
    match /friend_requests/{requestId} {
      // Read: if you're the sender or receiver
      allow read: if isAuthenticated() && 
                     (resource.data.fromUserId == request.auth.uid || 
                      resource.data.toUserId == request.auth.uid);
      
      // Create: if you're the sender
      allow create: if isAuthenticated() && 
                       request.resource.data.fromUserId == request.auth.uid;
      
      // Update: if you're the receiver (for accepting/rejecting)
      allow update: if isAuthenticated() && 
                       resource.data.toUserId == request.auth.uid;
      
      // Delete: if you're involved in the request
      allow delete: if isAuthenticated() && 
                       (resource.data.fromUserId == request.auth.uid || 
                        resource.data.toUserId == request.auth.uid);
    }
    
    // =============================================================================
    // SYSTEM COLLECTIONS (Optional)
    // =============================================================================
    
    // Configuration collection for app settings
    match /config/{configId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && 
                      get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      allow read, write: if isAuthenticated() && 
                            resource.data.userId == request.auth.uid;
    }
    
    // =============================================================================
    // CATCH-ALL RULES FOR FUTURE COLLECTIONS
    // =============================================================================
    
    // Default security for any new collections you might add
    match /{collection}/{docId} {
      // Basic authenticated access - you can override specific collections above
      allow read, write: if isAuthenticated();
    }
  }
}