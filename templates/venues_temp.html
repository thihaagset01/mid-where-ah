<!-- templates/venues_temp.html - FIXED VERSION -->
{% extends "mobile_base.html" %}

{% block title %}Top Picks - MidWhereAh{% endblock %}

{% block head %}
{{ super() }}
<link rel="stylesheet" href="{{ url_for('static', filename='css/venue-cards.css') }}">
<style>
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    color: white;
}

.filter-controls {
    background: white;
    padding: 15px;
    border-bottom: 1px solid #eee;
    display: flex;
    gap: 10px;
    overflow-x: auto;
}

.filter-btn {
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 20px;
    background: white;
    white-space: nowrap;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
}

.filter-btn.active {
    background: var(--primary-purple);
    color: white;
    border-color: var(--primary-purple);
}

.venue-rank {
    position: absolute;
    top: -5px;
    right: -5px;
    background: var(--primary-purple);
    color: white;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

.vote-count {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    color: #666;
}

.vote-count i {
    color: #e74c3c;
}

/* Navigation toggle button styling */
.nav-toggle-btn {
    background: var(--primary-purple);
    border: none;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    position: fixed;
    bottom: 80px;
    right: 20px;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(139, 93, 184, 0.3);
    transition: all 0.3s ease;
}

.nav-toggle-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(139, 93, 184, 0.4);
}
</style>
{% endblock %}

{% block content %}
<header class="venue-header">
    <div class="container-fluid">
        <div class="d-flex justify-content-between align-items-center">
            <button class="btn btn-link p-0" onclick="goBack()">
                <i class="fas fa-arrow-left"></i> Back
            </button>
            <h1 class="h5 mb-0">
                <i class="fas fa-trophy me-2 text-warning"></i>
                Top Picks
            </h1>
            <div style="width: 40px;"></div> <!-- Spacer -->
        </div>
    </div>
</header>

<!-- Filter Controls -->
<div class="filter-controls" id="filter-controls">
    <button class="filter-btn active" data-sort="votes" onclick="sortVenues('votes', this)">
        <i class="fas fa-heart me-1"></i> Most Liked
    </button>
    <button class="filter-btn" data-sort="rating" onclick="sortVenues('rating', this)">
        <i class="fas fa-star me-1"></i> Highest Rated
    </button>
    <button class="filter-btn" data-sort="price" onclick="sortVenues('price', this)">
        <i class="fas fa-dollar-sign me-1"></i> Price
    </button>
    <button class="filter-btn" data-sort="distance" onclick="sortVenues('distance', this)">
        <i class="fas fa-map-marker-alt me-1"></i> Nearest
    </button>
</div>

<main class="venue-content">
    <!-- Midpoint Info Summary -->
    <div class="midpoint-info" id="midpoint-summary">
        <span class="stat-item"><span class="stat-value" id="fairness-score">-</span> Fairness</span>
        <span class="stat-item"><span class="stat-value" id="avg-time">-</span> Avg Time</span>
        <span class="stat-item"><span class="stat-value" id="venue-count">-</span> Venues</span>
    </div>

    <!-- Venues Grid - Read-only results view -->
    <div class="venues-grid">
        <div id="venues-container">
            <div class="empty-state">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading venues...</span>
                </div>
                <p class="mt-3">Loading top picks...</p>
            </div>
        </div>
    </div>
</main>

<!-- Toggle Button - Changes based on context -->
<button class="nav-toggle-btn" id="nav-toggle-btn" onclick="toggleVotingView()" title="Switch to voting">
    <i class="fas fa-heart"></i>
</button>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
// Global variables
let isFirebaseReady = false;
let currentVenues = [];
let currentSort = 'votes';
let groupId = null;

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initializeFirebaseAuth();
        loadTempVenues();
    } catch (error) {
        console.error('Initialization error:', error);
        loadTempVenues();
    }
});

// Initialize Firebase auth state
function initializeFirebaseAuth() {
    return new Promise((resolve) => {
        if (typeof firebase === 'undefined') {
            console.warn('Firebase not available');
            isFirebaseReady = false;
            resolve(null);
            return;
        }

        const unsubscribe = firebase.auth().onAuthStateChanged((user) => {
            isFirebaseReady = true;
            unsubscribe();
            console.log('Firebase auth ready, user:', user ? user.email : 'not logged in');
            resolve(user);
        });
        
        setTimeout(() => {
            if (!isFirebaseReady) {
                console.warn('Firebase auth timeout');
                isFirebaseReady = true;
                unsubscribe();
                resolve(null);
            }
        }, 5000);
    });
}

// Load venue data and determine context - FIXED VERSION
function loadTempVenues() {
    try {
        const tempData = sessionStorage.getItem('tempVenues');
        console.log('Raw sessionStorage data:', tempData);
        
        if (!tempData) {
            showEmptyState('No venue data found. Please go back and calculate a midpoint first.');
            return;
        }

        const venueData = JSON.parse(tempData);
        console.log('Parsed venue data:', venueData);
        console.log('Venues array:', venueData.venues);
        console.log('Venues array length:', venueData.venues?.length);

        // Store group context
        groupId = venueData.groupId;
        
        // Update UI based on context
        updateBackButton(venueData.source, venueData.groupId, venueData.eventId);
        updateToggleButton(venueData.groupId);
        updateMidpointInfo(venueData);
        
        // Check if venues exist
        if (!venueData.venues || venueData.venues.length === 0) {
            console.warn('No venues in data, searching around midpoint...');
            
            // Try to search for venues around the midpoint
            if (venueData.midpoint) {
                searchVenuesAroundMidpoint(venueData.midpoint, venueData);
            } else {
                showEmptyState('No venues found near the meeting point. Try adjusting your location inputs.');
            }
            return;
        }
        
        // Load venues with vote data if group context
        if (venueData.groupId) {
            loadVenuesWithVotes(venueData);
        } else {
            displayReadOnlyVenues(venueData.venues);
        }
        
    } catch (error) {
        console.error('Error loading venue data:', error);
        showEmptyState('Error loading venue data. Please try again.');
    }
}

// Search for venues around midpoint if none provided
function searchVenuesAroundMidpoint(midpoint, venueData) {
    if (!window.google?.maps?.places?.PlacesService) {
        showEmptyState('Google Places service not available. Please try again later.');
        return;
    }

    console.log('ðŸ” Searching for venues around midpoint:', midpoint);
    
    // Create a temporary map element for the PlacesService
    const tempMapDiv = document.createElement('div');
    const tempMap = new google.maps.Map(tempMapDiv, { center: midpoint, zoom: 15 });
    const service = new google.maps.places.PlacesService(tempMap);
    
    const request = {
        location: new google.maps.LatLng(midpoint.lat, midpoint.lng),
        radius: 1000, // 1km radius
        type: ['restaurant', 'cafe', 'food', 'meal_takeaway'],
        keyword: 'restaurant cafe food dining'
    };

    service.nearbySearch(request, (results, status) => {
        console.log('Places API response:', status, results);
        
        if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length > 0) {
            // Sort by rating and limit to top venues
            const sortedVenues = results
                .filter(place => place.rating && place.rating > 3.0)
                .sort((a, b) => (b.rating || 0) - (a.rating || 0))
                .slice(0, 20);
            
            console.log(`âœ… Found ${sortedVenues.length} venues via Places API`);
            
            // Update venue data and display
            venueData.venues = sortedVenues;
            displayReadOnlyVenues(sortedVenues);
            updateMidpointInfo({ ...venueData, venues: sortedVenues });
        } else {
            console.error('Places API failed:', status);
            showEmptyState('No restaurants or cafes found near the meeting point. Try a different location.');
        }
    });
}

// Load venues with voting data from Firestore
async function loadVenuesWithVotes(venueData) {
    try {
        if (!venueData.groupId) {
            displayReadOnlyVenues(venueData.venues);
            return;
        }

        // Get votes from Firestore
        const votesSnapshot = await firebase.firestore()
            .collection('groups')
            .doc(venueData.groupId)
            .collection('votes')
            .get();

        // Process votes
        const allVotes = {};
        votesSnapshot.forEach(doc => {
            const userVotes = doc.data().votes || {};
            Object.keys(userVotes).forEach(venueId => {
                if (!allVotes[venueId]) {
                    allVotes[venueId] = { likes: 0, total: 0 };
                }
                allVotes[venueId].total++;
                if (userVotes[venueId] === 'yes') {
                    allVotes[venueId].likes++;
                }
            });
        });

        // Merge venue data with vote counts
        const venuesWithVotes = venueData.venues.map(venue => {
            const venueId = venue.placeId || venue.place_id;
            const voteData = allVotes[venueId] || { likes: 0, total: 0 };
            return {
                ...venue,
                votes: voteData,
                voteScore: voteData.total > 0 ? voteData.likes / voteData.total : 0
            };
        });

        currentVenues = venuesWithVotes;
        sortVenues('votes'); // Default sort by votes

    } catch (error) {
        console.error('Error loading votes:', error);
        displayReadOnlyVenues(venueData.venues);
    }
}

// Display venues in read-only results format
function displayReadOnlyVenues(venues) {
    if (!venues || venues.length === 0) {
        showEmptyState('No venues found near the meeting point.');
        return;
    }

    currentVenues = venues.map(venue => ({ ...venue, votes: { likes: 0, total: 0 }, voteScore: 0 }));
    sortVenues(currentSort);
}

// Sort venues by different criteria
function sortVenues(sortBy, buttonElement) {
    currentSort = sortBy;
    
    // Update active filter button
    if (buttonElement) {
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        buttonElement.classList.add('active');
    }

    let sortedVenues = [...currentVenues];
    
    switch (sortBy) {
        case 'votes':
            sortedVenues.sort((a, b) => {
                if (b.voteScore !== a.voteScore) return b.voteScore - a.voteScore;
                return (b.votes?.likes || 0) - (a.votes?.likes || 0);
            });
            break;
        case 'rating':
            sortedVenues.sort((a, b) => (b.rating || 0) - (a.rating || 0));
            break;
        case 'price':
            sortedVenues.sort((a, b) => (a.price_level || 0) - (b.price_level || 0));
            break;
        case 'distance':
            // Would need distance calculation - for now use rating as fallback
            sortedVenues.sort((a, b) => (b.rating || 0) - (a.rating || 0));
            break;
    }

    displaySortedVenues(sortedVenues);
}

// Display sorted venues
function displaySortedVenues(venues) {
    let html = '';
    venues.forEach((venue, index) => {
        html += createResultsVenueCard(venue, index + 1);
    });

    document.getElementById('venues-container').innerHTML = html;
}

// Create venue card for results view (read-only)
function createResultsVenueCard(venue, rank) {
    const photoUrl = getVenuePhotoUrl(venue);
    const photoHtml = photoUrl 
        ? `<img src="${photoUrl}" class="card-img-top venue-photo" alt="${venue.name}" loading="lazy">`
        : `<div class="card-img-top venue-photo-placeholder d-flex align-items-center justify-content-center">
             <i class="fas fa-utensils text-muted"></i>
           </div>`;

    const address = venue.vicinity || venue.formatted_address || 'Address not available';
    const priceLevel = venue.price_level ? '$'.repeat(venue.price_level) : '$';
    const rating = venue.rating ? `${venue.rating.toFixed(1)}` : 'N/A';
    const ratingClass = venue.rating >= 4 ? 'text-success' : venue.rating >= 3 ? 'text-warning' : 'text-danger';

    const voteCount = venue.votes ? venue.votes.likes : 0;
    const totalVotes = venue.votes ? venue.votes.total : 0;
    const votePercentage = totalVotes > 0 ? Math.round((voteCount / totalVotes) * 100) : 0;

    // Get coordinates for map link (handle both legacy and new Places API formats)
    let lat = 0, lng = 0;
    if (venue.geometry?.location) {
        // Try function format first (new API)
        if (typeof venue.geometry.location.lat === 'function') {
            lat = venue.geometry.location.lat();
            lng = venue.geometry.location.lng();
        } else {
            // Use direct property format (legacy API)
            lat = venue.geometry.location.lat || 0;
            lng = venue.geometry.location.lng || 0;
        }
    }

    return `
    <div class="card venue-card mb-3 position-relative">
        <div class="venue-rank">${rank}</div>
        <div class="row g-0">
            <div class="col-4 p-0">
                ${photoHtml}
            </div>
            <div class="col-8">
                <div class="card-body p-2">
                    <h6 class="card-title mb-1 text-truncate">${venue.name || 'Unnamed Venue'}</h6>
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <span class="badge ${ratingClass} bg-light">
                            <i class="fas fa-star me-1"></i>${rating}
                        </span>
                        <span class="text-muted small">${priceLevel}</span>
                    </div>
                    <p class="card-text small text-muted mb-1">
                        <i class="fas fa-map-marker-alt me-1"></i>
                        <span class="text-truncate d-inline-block" style="max-width: 180px;" 
                              title="${address}">${address}</span>
                    </p>
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="vote-count">
                            <i class="fas fa-heart"></i>
                            <span>${voteCount} likes</span>
                            ${totalVotes > 0 ? `<span class="text-muted">(${votePercentage}%)</span>` : ''}
                        </div>
                        <button class="btn btn-outline-primary btn-sm" 
                                onclick="viewOnMap('${venue.placeId || venue.place_id}', ${lat}, ${lng})">
                            <i class="fas fa-map-marker-alt me-1"></i> Map
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>`;
}

// Update toggle button based on context
function updateToggleButton(groupId) {
    const toggleBtn = document.getElementById('nav-toggle-btn');
    if (!toggleBtn) return;

    if (groupId) {
        // Show voting toggle - heart icon for swipe voting
        toggleBtn.innerHTML = '<i class="fas fa-heart"></i>';
        toggleBtn.title = 'Switch to Swipe Voting';
        toggleBtn.style.display = 'flex';
    } else {
        // Hide toggle for non-group contexts
        toggleBtn.style.display = 'none';
    }
}

// Toggle between results view and voting view
function toggleVotingView() {
    if (!groupId) {
        showToast('Group context required for voting', 'error');
        return;
    }

    // Navigate to swipe voting interface
    startSwipeVoting(groupId);
}

// Navigate to swipe voting with proper authentication
async function startSwipeVoting(groupId) {
    try {
        if (!isFirebaseReady || !firebase.auth().currentUser) {
            showToast('Please sign in to start voting', 'error');
            return;
        }

        const user = firebase.auth().currentUser;
        console.log('Starting swipe voting for user:', user.email);

        // Get fresh token and sync session
        const idToken = await user.getIdToken(true);
        
        // Set cookie with proper attributes
        const isSecure = window.location.protocol === 'https:';
        document.cookie = `id_token=${idToken}; path=/; max-age=3600; ${isSecure ? 'secure; ' : ''}samesite=lax`;
        
        // Sync with Flask session
        const response = await fetch('/api/user', {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${idToken}`,
                'Content-Type': 'application/json'
            },
            credentials: 'include'
        });

        if (response.ok) {
            console.log('Session synced, navigating to swipe interface');
            // Store return path
            sessionStorage.setItem('swipe_return_path', window.location.href);
            // Navigate to swipe interface
            window.location.href = `/mobile/swipe/${groupId}`;
        } else {
            throw new Error('Session sync failed');
        }

    } catch (error) {
        console.error('Error starting swipe voting:', error);
        showToast('Failed to start voting. Please try refreshing the page.', 'error');
    }
}

// Update back button behavior
function updateBackButton(source, groupId, eventId) {
    const backButton = document.querySelector('.btn-link');
    if (!backButton) return;
    
    if (source === 'event_map' && groupId && eventId) {
        backButton.onclick = () => {
            window.location.href = `/event_map_manager?eventId=${eventId}&groupId=${groupId}`;
        };
    } else {
        backButton.onclick = goBack;
    }
}

// Go back function
function goBack() {
    // Try to go back in browser history
    if (window.history.length > 1) {
        window.history.back();
    } else {
        // Fallback to home page
        window.location.href = '/app';
    }
}

// Update midpoint information
function updateMidpointInfo(data) {
    const statsContainer = document.getElementById('midpoint-summary');
    
    if (data.fairness !== undefined || data.avgTime !== undefined || data.venues) {
        statsContainer.style.display = 'flex';
        
        const fairnessEl = document.getElementById('fairness-score');
        const avgTimeEl = document.getElementById('avg-time');
        const venueCountEl = document.getElementById('venue-count');
        
        if (fairnessEl) fairnessEl.textContent = data.fairness ? `${Math.round(data.fairness * 100)}%` : '-';
        if (avgTimeEl) avgTimeEl.textContent = data.avgTime ? `${Math.round(data.avgTime)} min` : '-';
        if (venueCountEl) venueCountEl.textContent = data.venues ? data.venues.length : '-';
    }
}

// Helper functions
function getVenuePhotoUrl(venue) {
    if (!venue.photos || venue.photos.length === 0) return null;
    const photo = venue.photos[0];
    if (photo.getUrl) {
        return photo.getUrl({ maxWidth: 400, maxHeight: 300 });
    }
    return `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference=${photo.photo_reference}&key=${window.googleMapsApiKey}`;
}

function showToast(message, type = 'info') {
    const toastId = `toast-${Date.now()}`;
    const bgClass = type === 'error' ? 'bg-danger' : type === 'success' ? 'bg-success' : 'bg-primary';
    
    const toast = document.createElement('div');
    toast.id = toastId;
    toast.className = `toast show align-items-center text-white ${bgClass} border-0`;
    toast.style.cssText = 'position: fixed; bottom: 20px; right: 20px; z-index: 9999; min-width: 250px;';
    
    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">${message}</div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" onclick="removeToast('${toastId}')"></button>
        </div>
    `;
    
    document.body.appendChild(toast);
    setTimeout(() => removeToast(toastId), 5000);
}

function removeToast(toastId) {
    const toast = document.getElementById(toastId);
    if (toast?.parentNode) {
        toast.classList.remove('show');
        setTimeout(() => toast.parentNode.removeChild(toast), 300);
    }
}

function showEmptyState(message) {
    document.getElementById('venues-container').innerHTML = `
        <div class="empty-state text-center py-5">
            <i class="fas fa-utensils fa-3x text-muted mb-3"></i>
            <h4>No Venues Found</h4>
            <p class="text-muted">${message}</p>
            <button class="btn btn-primary mt-3" onclick="goBack()">Go Back</button>
        </div>`;
}

function viewOnMap(placeId, lat, lng) {
    if (lat && lng) {
        const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}&query_place_id=${placeId}`;
        window.open(mapsUrl, '_blank');
    } else {
        showToast('Location not available for this venue', 'error');
    }
}
</script>
{% endblock %}